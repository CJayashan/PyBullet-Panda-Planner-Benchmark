import pybullet as p
import pybullet_data
import time
import math
import os
import glob
import random
import cv2
import shutil
import numpy as np
import scipy.io as scio
import sys
import scipy.stats as ss
import skimage.transform as skt
sys.path.append('/home/withanage/projects/pybullet/pybullet_grasp')

# Image dimensions
IMAGEWIDTH = 640
IMAGEHEIGHT = 480

nearPlane = 0.01  # Near clipping plane
farPlane = 10     # Far clipping plane

fov = 60    # Vertical field of view (in degrees). Image height = tan(30) * 0.7 * 2 = 0.8082903m
aspect = IMAGEWIDTH / IMAGEHEIGHT  # Aspect ratio of the camera


def imresize(image, size, interp="nearest"):
    """
    Resize image using skimage transform with specified interpolation method.
    
    Args:
        image: Input image array
        size: Target size (tuple/list) or scale factor (float/int)
        interp: Interpolation method ("nearest", "bilinear", etc.)
    
    Returns:
        Resized image array
    """
    skt_interp_map = {
        "nearest": 0,
        "bilinear": 1,
        "biquadratic": 2,
        "bicubic": 3,
        "biquartic": 4,
        "biquintic": 5
    }
    if interp in ("lanczos", "cubic"):
        raise ValueError("'lanczos' and 'cubic'"
                         " interpolation are no longer supported.")
    assert interp in skt_interp_map, ("Interpolation '{}' not"
                                      " supported.".format(interp))

    if isinstance(size, (tuple, list)):
        output_shape = size
    elif isinstance(size, (float)):
        np_shape = np.asarray(image.shape).astype(np.float32)
        np_shape[0:2] *= size
        output_shape = tuple(np_shape.astype(int))
    elif isinstance(size, (int)):
        np_shape = np.asarray(image.shape).astype(np.float32)
        np_shape[0:2] *= size / 100.0
        output_shape = tuple(np_shape.astype(int))
    else:
        raise ValueError("Invalid type for size '{}'.".format(type(size)))

    return skt.resize(image,
                      output_shape,
                      order=skt_interp_map[interp],
                      anti_aliasing=False,
                      mode="constant")

def inpaint(img, missing_value=0):
    """
    Inpaint missing values in depth image using OpenCV's inpainting algorithm.
    
    Args:
        img: Input depth image
        missing_value: Value to be considered as missing (default: 0)
    
    Returns:
        Inpainted image with missing values filled
    """
    img = cv2.copyMakeBorder(img, 1, 1, 1, 1, cv2.BORDER_DEFAULT)
    mask = (img == missing_value).astype(np.uint8)

    # Scale to keep as float, but has to be in bounds -1:1 to keep opencv happy
    scale = np.abs(img).max()
    img = img.astype(np.float32) / scale  # Has to be float32, 64 not supported
    img = cv2.inpaint(img, mask, 1, cv2.INPAINT_NS)

    # Back to original size and value range
    img = img[1:-1, 1:-1]
    img = img * scale

    return img


class SimEnv(object):
    """
    Virtual Environment Class
    
    Handles the simulation environment including object loading, camera setup,
    and environment manipulation.
    """
    def __init__(self, bullet_client, path, gripperId=None, custom_place_points=None):
        """
        Initialize simulation environment
        
        Args:
            bullet_client: PyBullet client instance
            path: Path to model directory
            gripperId: ID of the gripper if present (default: None)
        """
        self.custom_place_points = custom_place_points
        self.p = bullet_client
        self.p.setPhysicsEngineParameter(maxNumCmdPer1ms=1000, solverResidualThreshold=0, enableFileCaching=0)
        self.p.resetDebugVisualizerCamera(
            cameraDistance=1.2000000476837158, 
            cameraYaw=-55.200016021728516, 
            cameraPitch=-26.79999542236328, 
            cameraTargetPosition=[0.34499678015708923, -0.32521092891693115, 0.22291213274002075])
        self.p.setAdditionalSearchPath(pybullet_data.getDataPath())  # Add search path
        self.planeId = self.p.loadURDF("plane.urdf", [0, 0, 0])  # Load ground plane    
        self.p.setGravity(0, 0, -10)  # Set gravity
        self.flags = self.p.URDF_ENABLE_CACHED_GRAPHICS_SHAPES
        self.gripperId = gripperId
        self.buildShelfCabinet(with_side_walls=True)  # set to False to remove walls

        # Initialize camera
        self.movecamera(0, 0)
        self.projectionMatrix = self.p.computeProjectionMatrixFOV(fov, aspect, nearPlane, farPlane)


        self.num_urdf = 0  # Number of loaded URDFs
        self.urdfs_id = []  # Store model IDs generated by PyBullet
        
        # Predefined rotation angles for objects
        self.EulerRPList = [[0, 0], [math.pi/2, 0], [-1*math.pi/2, 0], 
                           [math.pi, 0], [0, math.pi/2], [0, -1*math.pi/2]]
        """
        Old dynamic placement marker generator (disabled)
        x_center = 0.5
        y_center = -0.5
        shelf_width = 0.5
        z_bottom = 0.8
        z_top = 1.1
        step_y = shelf_width / 4

        for y_offset in [-step_y, 0, step_y]:
        self.PLACE_POINTS.append([x_center, y_center + y_offset, z_bottom])
        self.PLACE_POINTS.append([x_center, y_center + y_offset, z_top])
        
        # Add shelf place markers (for grasp placement)
        # Allow custom placement points externally
        if hasattr(self, 'custom_place_points') and self.custom_place_points is not None:
            self.PLACE_POINTS = self.custom_place_points
        else:
            x_center = 0.5
            y_center = -0.5
            shelf_width = 0.5      # from buildShelfCabinet
            z_bottom = 0.8
            z_top = 1.1
            step_y = shelf_width / 4  # how far each marker spreads from center

            self.PLACE_POINTS = []
            for y_offset in [-step_y, 0, step_y]:
                self.PLACE_POINTS.append([x_center, y_center + y_offset, z_bottom])
                self.PLACE_POINTS.append([x_center, y_center + y_offset, z_top]) """
        
        # Placement points updated based on tested reachable positions
        place_pointx = 0.57
        self.PLACE_POINTS = [
            [place_pointx, -0.625, 0.6],
            [place_pointx, -0.5,   0.6],
            [place_pointx, -0.375, 0.6],
            [place_pointx, -0.625, 0.8],
            [place_pointx, -0.5,   0.8],
            [place_pointx, -0.375, 0.8],]
        
        self._createShelfMarkers()

        
    def buildShelfCabinet(self, origin=[-0.5, 0, 0.05], width=0.3, depth=0.3, height=0.3, shelf_thickness=0.02,
                          with_side_walls=True):
        """
        Build a cabinet with two shelf layers and side walls (open front/back).

        Args:
            origin: bottom-center of the cabinet [x, y, z]
            width: total width (x-direction)
            depth: total depth (y-direction)
            height: total height (z-direction)
            shelf_thickness: thickness of each wall or shelf
        """
        CABINET_WIDTH = 0.6     # x-axis, side-to-side
        CABINET_DEPTH = 0.2       # y-axis, front-to-back
        CABINET_HEIGHT = 0.8    # z-axis, total height
        SHELF_THICKNESS = 0.02     # thickness of each panel

        DIST_FROM_ROBOT = 0.45     # safe gap from robot (in x-direction)

        ARM_Y = -0.5               # robot arm y-position (center line)
        ARM_Z = 0.35               # approx height of robot arm (adjust if needed)

        # Cabinet center (aligned in Y, positioned left of robot in X)
        x = 0.62                 # distance left of robot
        y = ARM_Y 
        z = 0.0  # so middle shelf matches gripper height
        z_offset = 0.05

        self.shelf_ids = []  # to store all shelf part IDs

        p = self.p
        mass = 0  # static
        orn = p.getQuaternionFromEuler([0, 0, math.pi / 2])  # Rotate 90 degrees around Z axis

        # Bottom shelf
        body_id = p.createMultiBody(baseMass=mass,baseCollisionShapeIndex=p.createCollisionShape(
            p.GEOM_BOX, halfExtents=[CABINET_WIDTH / 2, CABINET_DEPTH / 2, SHELF_THICKNESS / 2]
            ),
            basePosition=[x, y, z + SHELF_THICKNESS / 2],
            baseOrientation=orn)
        self.shelf_ids.append(body_id)
        
        # Middle shelf (2nd layer)
        body_id = p.createMultiBody(
            baseMass=mass,
            baseCollisionShapeIndex=p.createCollisionShape(
                p.GEOM_BOX, halfExtents=[CABINET_WIDTH / 2, CABINET_DEPTH / 2, SHELF_THICKNESS / 2]
                ),
                basePosition=[x, y, 0.6 - SHELF_THICKNESS / 2- z_offset],
                baseOrientation=orn)
        self.shelf_ids.append(body_id)

        # Top cover
        body_id = p.createMultiBody(
            baseMass=mass,
            baseCollisionShapeIndex=p.createCollisionShape(
                p.GEOM_BOX, halfExtents=[CABINET_WIDTH / 2, CABINET_DEPTH / 2, SHELF_THICKNESS / 2]
                ),
                basePosition=[x, y, z + CABINET_HEIGHT - SHELF_THICKNESS / 2- z_offset],
                baseOrientation=orn)
        self.shelf_ids.append(body_id)
        
        if with_side_walls:
            # Left side wall
            body_id = p.createMultiBody(
                baseMass=mass,
                baseCollisionShapeIndex=p.createCollisionShape(
                    p.GEOM_BOX, halfExtents=[SHELF_THICKNESS / 2, CABINET_DEPTH / 2, CABINET_HEIGHT / 2]
                    ),
                    basePosition=[x , y + CABINET_WIDTH/ 2 - SHELF_THICKNESS / 2, z + CABINET_HEIGHT / 2],
                    baseOrientation=orn)
            self.shelf_ids.append(body_id) 

            # Right side wall
            body_id = p.createMultiBody(
                baseMass=mass,
                baseCollisionShapeIndex=p.createCollisionShape(
                    p.GEOM_BOX, halfExtents=[SHELF_THICKNESS / 2, CABINET_DEPTH / 2, CABINET_HEIGHT / 2]
                    ),
                    basePosition=[x, y - CABINET_WIDTH/2 + SHELF_THICKNESS / 2, z + CABINET_HEIGHT / 2],
                    baseOrientation=orn)
            self.shelf_ids.append(body_id) 
        
            
    def _createShelfMarkers(self):
        """
        Create small visual sphere markers at the target positions on the shelf.
        """
        visual_shape = self.p.createVisualShape(
            shapeType=self.p.GEOM_SPHERE,
            radius=0.008,  # small dot
            rgbaColor=[1, 0, 0, 1]  # red color
            )

        for pos in self.PLACE_POINTS :
            self.p.createMultiBody(
                baseMass=0,
                baseVisualShapeIndex=visual_shape,
                basePosition=pos
                )


    def movecamera(self, x, y, z=0.7):
        """
        Move camera to specified position in world coordinates
        
        Args:
            x: X coordinate in world frame
            y: Y coordinate in world frame
            z: Z coordinate in world frame (default: 0.7m)
        """
        self.viewMatrix = self.p.computeViewMatrix([x, y, z], [x, y, 0], [0, 1, 0])   # Camera height set to 0.7m


    def createCube(self, size=0.05, mass=0.5, position=[0, 0, 0.05], orientation=[0, 0, 0]):
        """
        Create a solid cube in the simulation.

        Args:
            size (float): Half-size of the cube (edge length will be 2×size).
            mass (float): Mass of the cube.
            position (list): [x, y, z] position of the cube center.
            orientation (list): [roll, pitch, yaw] in radians.
        Returns:
            int: Body ID of the created cube.
        """
        cube_shape = self.p.createCollisionShape(
            shapeType=self.p.GEOM_BOX,
            halfExtents=[size, size, size]
            )
        quat = self.p.getQuaternionFromEuler(orientation)
        cube_id = self.p.createMultiBody(
            baseMass=mass,
            baseCollisionShapeIndex=cube_shape,
            basePosition=position,
            baseOrientation=quat
            )
        return cube_id

    def spawnCubes(self, idx, num):
        assert num == 6
        self.num_urdf = num
        self.urdfs_id = []
        self.urdfs_xyz = []

        cube_size = 0.03
        z = cube_size + 0.01

        grid_positions = [
            [-0.1, -0.1, z], [-0.1, 0.0, z], [-0.1, 0.1, z],
            [0.1, -0.1, z],  [0.1, 0.0, z],  [0.1, 0.1, z],
            ]

        for i in range(num):
            pos = grid_positions[i]
            euler = [0, 0, 0]
            cube_id = self.createCube(size=cube_size, mass=0.5, position=pos, orientation=euler)
            self.urdfs_id.append(cube_id)
            self.urdfs_xyz.append(pos)

            for _ in range(120):
                self.p.stepSimulation()


    def evalGrasp(self, z_thresh):
        """
        Evaluate if grasp is successful
        
        Args:
            z_thresh: Z-coordinate threshold. Object above this is considered grasped
            
        Returns:
            bool: True if grasp successful, False otherwise
        """
        for i in range(self.num_urdf):
            offset, _ =  self.p.getBasePositionAndOrientation(self.urdfs_id[i])
            if offset[2] >= z_thresh:
                print('!!!!!!!!!!!!!!!!!!!!! Success !!!!!!!!!!!!!!!!!!!!!')
                return True
        print('!!!!!!!!!!!!!!!!!!!!! Failed !!!!!!!!!!!!!!!!!!!!!')
        return False


    def evalGraspAndRemove(self, z_thresh):
        """
        Evaluate grasp success and remove grasped object
        
        Args:
            z_thresh: Z-coordinate threshold. Object above this is considered grasped
            
        Returns:
            bool: True if grasp successful, False otherwise
        """
        for i in range(self.num_urdf):
            offset, _ =  self.p.getBasePositionAndOrientation(self.urdfs_id[i])
            if offset[2] >= z_thresh:
                self.removeObjInURDF(i)
                print('!!!!!!!!!!!!!!!!!!!!! Success !!!!!!!!!!!!!!!!!!!!!')
                return True
        print('!!!!!!!!!!!!!!!!!!!!! Failed !!!!!!!!!!!!!!!!!!!!!')
        return False


    def resetObjsPoseRandom(self):
        """
        Randomly reset positions of all objects in the scene
        """
        for i in range(self.num_urdf):
            pos = 0.1
            basePosition = [random.uniform(-1 * pos, pos), 
                        random.uniform(-1 * pos, pos), 
                        random.uniform(0.3, 0.6)]
            baseEuler = [random.uniform(0, 2*math.pi), 
                        random.uniform(0, 2*math.pi), 
                        random.uniform(0, 2*math.pi)]
            baseOrientation = self.p.getQuaternionFromEuler(baseEuler)
            self.p.resetBasePositionAndOrientation(self.urdfs_id[i], 
                                                basePosition, 
                                                baseOrientation)

            # Let physics simulation stabilize
            t = 0
            while True:
                p.stepSimulation()
                t += 1
                if t == 120:
                    break


    def removeObjsInURDF(self):
        """
        Remove all objects from the scene and reset object counters
        """
        for i in range(self.num_urdf):
            self.p.removeBody(self.urdfs_id[i])
        self.num_urdf = 0
        self.urdfs_id = []
        self.urdfs_xyz = []
        self.urdfs_scale = []
        self.urdfs_filename = []
        self.objs_id = []


    def removeObjInURDF(self, i):
        """
        Remove specified object from the scene
        
        Args:
            i: Index of object to remove
        """
        self.num_urdf -= 1
        self.p.removeBody(self.urdfs_id[i])
        self.urdfs_id.pop(i)
        self.urdfs_xyz.pop(i)


    def renderCameraDepthImage(self):
        """
        Render depth image from camera viewpoint
        
        Returns:
            numpy.ndarray: Depth image in meters
        """
        # Render image
        img_camera = self.p.getCameraImage(
            IMAGEWIDTH, 
            IMAGEHEIGHT, 
            self.viewMatrix, 
            self.projectionMatrix, 
            renderer=p.ER_BULLET_HARDWARE_OPENGL
        )
        w = img_camera[0]      # Width of the image, in pixels
        h = img_camera[1]      # Height of the image, in pixels
        dep = img_camera[3]    # Depth data

        # Convert depth buffer to actual depth
        depth = np.reshape(dep, (h, w))
        A = np.ones((IMAGEHEIGHT, IMAGEWIDTH), dtype=np.float64) * farPlane * nearPlane
        B = np.ones((IMAGEHEIGHT, IMAGEWIDTH), dtype=np.float64) * farPlane
        C = np.ones((IMAGEHEIGHT, IMAGEWIDTH), dtype=np.float64) * (farPlane - nearPlane)
        im_depthCamera = np.divide(A, (np.subtract(B, np.multiply(C, depth))))  # Units in meters
        return im_depthCamera


    def renderCameraMask(self):
        """
        Render segmentation mask from camera viewpoint
        
        Returns:
            numpy.ndarray: Segmentation mask (255 for objects, 0 for background)
        """
        # Render image
        img_camera = self.p.getCameraImage(
            IMAGEWIDTH, 
            IMAGEHEIGHT, 
            self.viewMatrix, 
            self.projectionMatrix, 
            renderer=p.ER_BULLET_HARDWARE_OPENGL
        )
        w = img_camera[0]      # Width of the image, in pixels
        h = img_camera[1]      # Height of the image, in pixels
        mask = img_camera[4]   # Segmentation mask data

        # Process segmentation mask
        im_mask = np.reshape(mask, (h, w)).astype(np.uint8)
        im_mask[im_mask > 2] = 255  # Set all objects to 255
        return im_mask


    def gaussian_noise(self, im_depth):
        """
        Add Gaussian noise to depth image (based on Dex-Net implementation)
        
        Args:
            im_depth: Float depth image in meters
            
        Returns:
            numpy.ndarray: Depth image with added noise
        """
        gamma_shape = 1000.00
        gamma_scale = 1 / gamma_shape
        gaussian_process_sigma = 0.002
        gaussian_process_scaling_factor = 8.0

        im_height, im_width = im_depth.shape
        
        # Add Gaussian Process noise
        gp_rescale_factor = gaussian_process_scaling_factor
        gp_sample_height = int(im_height / gp_rescale_factor)
        gp_sample_width = int(im_width / gp_rescale_factor)
        gp_num_pix = gp_sample_height * gp_sample_width
        gp_sigma = gaussian_process_sigma
        
        # Generate and apply noise
        gp_noise = ss.norm.rvs(scale=gp_sigma, 
                            size=gp_num_pix).reshape(gp_sample_height, gp_sample_width)
        gp_noise = imresize(gp_noise, gp_rescale_factor, interp="bicubic")
        im_depth += gp_noise

        return im_depth


    def add_noise(self, img):
        """
        Add noise to depth image
        
        Args:
            img: Input depth image
            
        Returns:
            numpy.ndarray: Depth image with added noise
        """
        #img = self.gaussian_noise(img)    # Add Gaussian noise
        return img